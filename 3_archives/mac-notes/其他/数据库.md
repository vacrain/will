## 数据库的分类



- 关系型数据库
   对每一列的数据类型会有约束， id(整型)， name（字符串类型）
   maridb，MySQL -----》用的比较多，免费
   SqlServer -----》 微软， 大学，政府 （汽车之家）
   Oracle -----》甲骨文，收费，金融公司，阿里
   sqlite -----》小型的文件数据库，自己玩玩
   等
- 非关系型数据库
   memcache ----》十年前的产品 （新浪博客）
   mongodb ----》文档型数据库
   redis ------》微博
   {"name":'zekai'}
   {"name":12}
   {"name":[]}
   {"name":{}}





- 最大区别：

关系型数据库，把数据存在硬盘中（如MySQL的data文件夹）

非关系型数据库， 把数据存在内存中





# 1 设计三范式



## 第一范式:确保行不可再分

- 确保每列的原子性.
- 如果每列(或者每个属性)都是不可再分的最小数据单元(也称为最小的原子单元),则满足第一范式.
- 例如:顾客表(姓名、编号、地址、……)其中"地址"列还可以细分为国家、省、市、区等。



## 第二范式:确保都依赖主键

- 在第一范式的基础上更进一层,目标是确保表中的每列都和主键相关.

如果一个关系满足第一范式,并且除了主键以外的其它列,都依赖于该主键,则满足第二范式.

- 例如:订单表(订单编号、产品编号、定购日期、价格、……)，"订单编号"为主键，"产品编号"和主键列没有直接的关系，即"产品编号"列不依赖于主键列，应删除该列。

##  

## 第三范式:消除非主键字段传递依赖

- 在第二范式的基础上更进一层,目标是确保每列都和主键列直接相关,而不是间接相关.
- 如果一个关系满足第二范式,并且除了主键以外的其它列都不依赖于主键列,则满足第三范式.
- 为了理解第三范式，需要根据Armstrong公里之一定义传递依赖。假设A、B和C是关系R的三个属性，如果A-〉B且B-〉C，则从这些函数依赖中，可以得出A-〉C，如上所述，依赖A-〉C是传递依赖。
- 例如:订单表(订单编号，定购日期，顾客编号，顾客姓名，……)，初看该表没有问题，满足第二范式，每列都和主键列"订单编号"相关，再细看你会发现"顾客姓名"和"顾客编号"相关，"顾客编号"和"订单编号"又相关，最后经过传递依赖，"顾客姓名"也和"订单编号"相关。为了满足第三范式，应去掉"顾客姓名"列，放入客户表中。



# 2 SQL 



##  （1）SQL概念说明

- 结构化查询语言（Structured Query Language）简称SQL
- 是一种特殊目的的编程语言
- 是一种数据库查询和程序设计语言
- 用于存取数据以及查询、更新和管理关系型数据库系统。





## （2）结构化查询语言说明

- 高级的非过程化编程语言
- 允许用户在高层数据结构上工作
- 不要求用户指定或了解数据的存放方式
- 可以嵌套

# 3事务





**事务的**ACID原则：

- 事务的原子性(Atomicity)：是指一个事务要么全部执行，要么不执行，也就是说一个事务不可能只执行了一半就停止了。比如你从取款机取钱，这个事务可以分成两个步骤：1划卡，2出钱。不可能划了卡，而钱却没出来。这两步必须同时完成，要么就不完成。
- 事务的一致性(Consistency)：是指事务的运行并不改变数据库中数据的一致性。例如，完整性约束了a+b=10，一个事务改变了a，那么b也应该随之改变。
- 独立性(Isolation）：事务的独立性也称作隔离性，是指两个以上的事务不会出现交错执行的状态。因为这样可能会导致数据不一致，更加具体的来讲，就是事务之间的操作是独立的。
- 持久性(Durability）：事务的持久性是指事务执行成功以后，该事务对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚。





# 4 数据库设计三层模型



- 数据库建模：是对现实世界进行分析、抽象、并从中找出内在联系，进而确定数据库的结构。 
- 



参考：https://blog.csdn.net/t_332741160/article/details/62973232



参考图：

![20170317235040264.jpeg](/blob:file:/1082e1ca-7bf6-4d92-90cb-f7a51582b690)



## 三层结构说明



**1.**概念模型：

- 对现实世界的第一层抽象
- 确定领域 、实体、属性以及联系等
- 通过E-R图来表示
- E-R图由实体、属性和联系三个要素构成



**2.**逻辑模型：

- 将概念模型转化为具体的数据模型的过程

- 根据**E-R图**和选定的数据管理系统或软件所支持的**数据模型**（比如MySql支持关系型数据）（还有层次、网状、关系、面向对象等），转换成相应的逻辑模型。

- 这种转换要符合关系数据模型的原则，目前最流行的就是关系模型（也就是对应的关系数据库）

- E-R图转化为关系模型，要先将 **联系** 转化为 **关系**，然后确定这些关系的属性和码，一般原则如下：

- 1. 一个实体转化为一个关系，实体的属性就是关系的属性（字段），实体的码就是关系的码（主键）

  2. 一个联系也转化为一个关系，联系的属性及联系所连接的实体的码都转化为关系的属性，关系的码随着联系的类型变化：

  3. - 1:1联系，两端实体的码成为关系的码（外键）
     - 1:n联系，n端实体的码成为关系的码（外键）
     - m：n联系，两端实体码的组合成为关系的码（联合主键）



**3.**物理模型

- 将逻辑模型对应到具体数据模型的机器实现（保存到计算机）
- 是对真实数据库的描述
- 如：关系数据库中的一些对象为表、视图、字段、数据类型、长度、主键、外建、索引、约束、非空、默认值等

# 5 IN和EXISTS区别



https://www.cnblogs.com/emilyyoucan/p/7833769.html



# MyBatis JdbcType 与Oracle、MySql数据类型对应关系说明



| Mybatis  | JdbcType      | Oracle         | MySql              |
| -------- | ------------- | -------------- | ------------------ |
| JdbcType | ARRAY         |                |                    |
| JdbcType | BIGINT        |                | BIGINT             |
| JdbcType | BINARY        |                |                    |
| JdbcType | BIT           |                | BIT                |
| JdbcType | BLOB          | BLOB           | BLOB               |
| JdbcType | BOOLEAN       |                |                    |
| JdbcType | CHAR          | CHAR           | CHAR               |
| JdbcType | CLOB          | CLOB           | CLOB–>修改为TEXT   |
| JdbcType | CURSOR        |                |                    |
| JdbcType | DATE          | DATE           | DATE               |
| JdbcType | DECIMAL       | DECIMAL        | DECIMAL            |
| JdbcType | DOUBLE        | NUMBER         | DOUBLE             |
| JdbcType | FLOAT         | FLOAT          | FLOAT              |
| JdbcType | INTEGER       | INTEGER        | INTEGER            |
| JdbcType | LONGVARBINARY |                |                    |
| JdbcType | LONGVARCHAR   | LONG VARCHAR   |                    |
| JdbcType | NCHAR         | NCHAR          |                    |
| JdbcType | NCLOB         | NCLOB          |                    |
| JdbcType | NULL          |                |                    |
| JdbcType | NUMERIC       | NUMERIC/NUMBER | NUMERIC/           |
| JdbcType | NVARCHAR      |                |                    |
| JdbcType | OTHER         |                |                    |
| JdbcType | REAL          | REAL           | REAL               |
| JdbcType | SMALLINT      | SMALLINT       | SMALLINT           |
| JdbcType | STRUCT        |                |                    |
| JdbcType | TIME          |                | TIME               |
| JdbcType | TIMESTAMP     | TIMESTAMP      | TIMESTAMP/DATETIME |
| JdbcType | TINYINT       |                | TINYINT            |
| JdbcType | UNDEFINED     |                |                    |
| JdbcType | VARBINARY     |                |                    |
| JdbcType | VARCHAR       | VARCHAR        | VARCHAR            |

[**Oracle**数据类型对应Java类型](https://www.cnblogs.com/xkl520xka/p/5817180.html)

##  

| **SQL****数据类型**            | **JDBC****类型代码**                 | **标准的****Java****类型** | **Oracle****扩展的****Java****类型** |
| ------------------------------ | ------------------------------------ | -------------------------- | ------------------------------------ |
|                                | 1.0标准的JDBC类型:                   |                            |                                      |
| CHAR                           | java.sql.Types.CHAR                  | java.lang.String           | oracle.sql.CHAR                      |
| VARCHAR2                       | java.sql.Types.VARCHAR               | java.lang.String           | oracle.sql.CHAR                      |
| LONG                           | java.sql.Types.LONGVARCHAR           | java.lang.String           | oracle.sql.CHAR                      |
| NUMBER                         | java.sql.Types.NUMERIC               | java.math.BigDecimal       | oracle.sql.NUMBER                    |
| NUMBER                         | java.sql.Types.DECIMAL               | java.math.BigDecimal       | oracle.sql.NUMBER                    |
| NUMBER                         | java.sql.Types.BIT                   | boolean                    | oracle.sql.NUMBER                    |
| NUMBER                         | java.sql.Types.TINYINT               | byte                       | oracle.sql.NUMBER                    |
| NUMBER                         | java.sql.Types.SMALLINT              | short                      | oracle.sql.NUMBER                    |
| NUMBER                         | java.sql.Types.INTEGER               | int                        | oracle.sql.NUMBER                    |
| NUMBER                         | java.sql.Types.BIGINT                | long                       | oracle.sql.NUMBER                    |
| NUMBER                         | java.sql.Types.REAL                  | float                      | oracle.sql.NUMBER                    |
| NUMBER                         | java.sql.Types.FLOAT                 | double                     | oracle.sql.NUMBER                    |
| NUMBER                         | java.sql.Types.DOUBLE                | double                     | oracle.sql.NUMBER                    |
| RAW                            | java.sql.Types.BINARY                | byte[]                     | oracle.sql.RAW                       |
| RAW                            | java.sql.Types.VARBINARY             | byte[]                     | oracle.sql.RAW                       |
| LONGRAW                        | java.sql.Types.LONGVARBINARY         | byte[]                     | oracle.sql.RAW                       |
| DATE                           | java.sql.Types.DATE                  | java.sql.Date              | oracle.sql.DATE                      |
| DATE                           | java.sql.Types.TIME                  | java.sql.Time              | oracle.sql.DATE                      |
| TIMESTAMP                      | java.sql.Types.TIMESTAMP             | javal.sql.Timestamp        | oracle.sql.TIMESTAMP                 |
|                                | 2.0标准的JDBC类型:                   |                            |                                      |
| BLOB                           | java.sql.Types.BLOB                  | java.sql.Blob              | oracle.sql.BLOB                      |
| CLOB                           | java.sql.Types.CLOB                  | java.sql.Clob              | oracle.sql.CLOB                      |
| 用户定义的对象                 | java.sql.Types.STRUCT                | java.sql.Struct            | oracle.sql.STRUCT                    |
| 用户定义的参考                 | java.sql.Types.REF                   | java.sql.Ref               | oracle.sql.REF                       |
| 用户定义的集合                 | java.sql.Types.ARRAY                 | java.sql.Array             | oracle.sql.ARRAY                     |
|                                | Oracle扩展:                          |                            |                                      |
| BFILE                          | oracle.jdbc.OracleTypes.BFILE        | N/A                        | oracle.sql.BFILE                     |
| ROWID                          | oracle.jdbc.OracleTypes.ROWID        | N/A                        | oracle.sql.ROWID                     |
| REF CURSOR                     | oracle.jdbc.OracleTypes.CURSOR       | java.sql.ResultSet         | oracle.jdbc.OracleResultSet          |
| TIMESTAMP                      | oracle.jdbc.OracleTypes.TIMESTAMP    | java.sql.Timestamp         | oracle.sql.TIMESTAMP                 |
| TIMESTAMP WITH TIME ZONE       | oracle.jdbc.OracleTypes.TIMESTAMPTZ  | java.sql.Timestamp         | oracle.sql.TIMESTAMPTZ               |
| TIMESTAMP WITH LOCAL TIME ZONE | oracle.jdbc.OracleTypes.TIMESTAMPLTZ | java.sql.Timestamp         | oracle.sql.TIMESTAMPLTZ              |





# SB连接Oracle





![Screen Shot 2020-09-29 at 14.24.57.png](/blob:file:/cd464b3f-8015-460a-a06a-e83bb1873b45)



jdbc:oracle:thin:@localhost:1521:XE



![Screen Shot 2020-09-29 at 14.23.48.png](/blob:file:/fce30f66-e017-422e-bc23-73a3af187868)



**配置主文件：**



spring.datasource.url=jdbc:oracle:thin:@localhost:1521:XE

spring.datasource.username=admin

spring.datasource.password=123456

spring.datasource.driver-class-name=oracle.jdbc.OracleDriver



server.port=8081









# Mysql

2019-12-30T03:04:41.024706Z 1 [Note] A temporary password is generated for root@localhost: we3eLNH:yERK



If you lose this password, please consult the section How to Reset the Root Password in the MySQL reference manual.





# 新建连接密码

root





Mysql数据库必须掌握：SQL添加、SQL修改、SQL删除、SQL查询(重点、难点)。

Mysql数据库扩展内容：约束、limit关键字、视图、关联关系、事务。工具参考手册。百度。



(一)约束

说明：数据库设计、开发中使用建模工具生成出来的。例如：PD等。



(1)不为空约束 NOT NULL

-- 注意：navicat工具设计表和实际开中不一样。

INSERT INTO t1 VALUES(6, 'x');

INSERT INTO t1 VALUES(7, NULL);

INSERT INTO t1 VALUES(8, NULL);

INSERT INTO t1(id) VALUES(8);





(2)唯一约束 UNIQUE

INSERT INTO t1 VALUES(7, 'y');



(3)主键约束(不为空 + 唯一) PRIMARY KEY

INSERT INTO t1(id) VALUES(NULL);

INSERT INTO t1(id) VALUES(1);



(4)外键约束 FOREIGN KEY

-- 注意：先删除子表中的数据、再删除主表中的数据。

SELECT * FROM t1;

SELECT * FROM t2;



DELETE FROM t2 WHERE comid = 1;

DELETE FROM t1 WHERE id = 1;



UPDATE t1 set id = 3 WHERE id = 1;

INSERT INTO t2 VALUES(4, '赵六', 3);





(二)LIMIT关键字



作用一：top-n分析、前几名、最大值

参数一：表示查询前几条记录。通常和ORDER BY排序连用。先排序再截取。

SELECT * FROM t1 ORDER BY age LIMIT 3



作用二：分页、截取表中的一段记录

参数一：表示起始位置、注意是从零开始计数

参数二：表示返回的记录数、通常和ORDER BY连用、通常按照id降序使用。

SELECT * FROM t1 ORDER BY id DESC

SELECT * FROM t1 ORDER BY id DESC LIMIT 2, 1





(三)视图

说明：数据库中有很多数据库对象、例如：表、视图、索引、序列、存储过程、触发器等。

表：存储数据。

视图：select查询语句的定义。高效、安全、方便。

索引：提高查询效率。(书的目录、数据库优化、通常是对搜索字段添加索引)。

序列：一组有规则的数值。(生成主键、Hibernate、id生成器、有很多替代技术)。

存储过程：PLQL编程内容。相当于数据库中的方法、可以调用。认为调用。

触发器：PLQL编程内容。在对表中数据进行添加、修改、删除操作之后出发的方法。自动调用。

说明：SQL语句是所有关系型数据库通用的结构化查询语言。

但是不同的数据库的编程语言是不同的。

Mysql、Oracle：PLSQ编程语言。

SQLServer：TSQL编程语言。转移到数据库开发。



视图的概念：select查询语句的定义而已。



创建表

CREATE TABLE t3(

id int(2) PRIMARY KEY,

name VARCHAR(10) NOT NULL,

tel VARCHAR(20)

);

删除表

DROP TABLE t3;



创建视图

CREATE OR REPLACE VIEW view01 AS

SELECT t1.id id3, t1.name name4, t2.id id2, t2.name name2 FROM t1, t2 WHERE t1.id = t2.comid;



查询视图

说明一：from后边可以写表、也可以写视图

说明二：from子查询的本质就是临时视图

说明三：开发中可以把复杂的查询语句定义为视图存储到数据库端

视图好处：简单、安全、高效。表->视图->我们开发

SELECT * FROM view01;

SELECT * FROM (SELECT t1.id id1, t1.name name1, t2.id id2, t2.name name2 FROM t1, t2 WHERE t1.id = t2.comid) t



删除视图

注意：删除视图只是把sql定义删除了、对表没有任何影响。

DROP VIEW view01;





(四)表与表之间的关联关系

一对一关联：A表中的一条记录对一B表中的一条记录。用户信息（基本信息表、私密信息表）

一对多关联：A表中的一条记录对一B表中的多条记录。项目最最常见。

多对多关联：A表中的一条记录对一B表中的多条记录。B表中的一条记录对一A表中的多条记录。

注意：多对表关联会拆分成2个一对多关联、通过会有一个中间表。

A表		-		C表中间表		-		B表





(五)数据库事务(安全)

事务的概念：一组SQL语句的操作单元、这些SQL语句是一个整体业务功能、要么都执行成功、要么都执行失败。

事务的概念：用户的一次请求就是一个事务。是一个不可分割的工作单位。



举例：银行转账的事务。

UPDATE bank set money = money-100 WHERE name = '李四';

UPDATE bank set money = money+100 WHERE name = '张三';

问题：怎么保证这个事务的一些列SQL语句是一个单元？怎么保证都执行、或都不执行。



演示：Mysql数据库为例

说明：mysql数据库的事务默认是自动提交的。



事务提交：把数据真正存储到表中。



演示事务自动提交的过程



由于事务是一组SQL语句的单元、这些SQL语句只有我们程序员知道哪些SQL是一个事务、因此在项目中事务需要设置为非自动提交。



注意：事务自动提交必须改为手动提交。否则



希望：



设置事务为非自动提交(手动提交、该事务是否提交由程序员来决定)

UPDATE bank set money = money-100 WHERE name = '李四';	成功

UPDATE bank set money = money+100 WHERE name = '张三'; 成功

如果所有SQL语句都执行成功则事务提交/如果其中SQL语句有执行失败的则事务回滚(回到数据初始状态)



事务提交：commit

事务回滚：rollback



查看事务状态

show variables like '%autocommit%';

设置事务为手动提交

set @@autocommit = 0;

设置事务为自动提交

set @@autocommit = 1;



事务的ACID原则

事务的原子性(Atomicity)：是指一个事务要么全部执行，要么不执行，也就是说一个事务不可能只执行了一半就停止了。比如你从取款机取钱，这个事务可以分成两个步骤：1划卡，2出钱。不可能划了卡，而钱却没出来。这两步必须同时完成，要么就不完成。

事务的一致性(Consistency)：是指事务的运行并不改变数据库中数据的一致性。例如，完整性约束了a+b=10，一个事务改变了a，那么b也应该随之改变。

独立性(Isolation）：事务的独立性也称作隔离性，是指两个以上的事务不会出现交错执行的状态。因为这样可能会导致数据不一致，更加具体的来讲，就是事务之间的操作是独立的。

持久性(Durability）：事务的持久性是指事务执行成功以后，该事务对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚。





# 练习1

一、使用Navicat工具实现如下功能

1、	创建数据库mydb0803

2、创建表employee， 代表员工信息表，表结构如下所示：

表名employee

字段名	数据类型	其他属性	字段说明

EmployeeID	字符，长度为6	不允许为空，主键	员工编号

EmployeeName	字符	不允许为空，最多20个字符	员工姓名

EmployeeIdentity	字符	不允许为空，不允许重复，最多18个字符	员工身份证号

JoinDate	日期类型	不允许为空	入职日期

EmployeeBirthday	日期类型	允许为空	员工生日

EmployeeTel	字符类型	允许为空，最多20个字符	员工电话号码



3、	向employee表中添加10条员工信息，要求如下：

1）	员工编号格式为“emp001”、员工姓名为中文

2）	有3名员工没有电话号码，

3）	有生日相同的员工，可以是不同年份的

INSERT INTO employee VALUES('emp001','张三1','222333188802010303','2020-01-01','1888-02-01','13312344321');

INSERT INTO employee VALUES('emp002','王二2','222333188802020303','2020-01-01','1882-02-02','13312344322');

INSERT INTO employee VALUES('emp003','张三3','222333188802030303','2020-01-01','1888-02-03',NULL);

INSERT INTO employee VALUES('emp004','李三4','222333188002020303','2020-01-01','1880-02-02','13312344324');

INSERT INTO employee VALUES('emp005','张三5','222333188802050303','2020-01-01','1888-02-05','13312344325');

INSERT INTO employee VALUES('emp006','张二6','222333188802060303','2020-01-01','1888-02-06',NULL);

INSERT INTO employee VALUES('emp007','李三7','222333188102010303','2020-01-01','1881-02-02','13312344327');

INSERT INTO employee VALUES('emp008','王三8','222333188802080303','2020-01-01','1888-02-08','13312344328');

INSERT INTO employee VALUES('emp009','张二9','222333188802090303','2020-01-01','1888-02-09','13312344329');

INSERT INTO employee VALUES('emp011','张三10','222333188802100303','2020-01-01','1888-02-10',NULL);



SELECT * FROM employee;



4、	创建表PositionMessage，代表职位信息表，表结构如下

表名PositionMessage

字段名	数据类型	其他属性	字段说明

PosID	字符	主键，最多3个字符	职位编号

PosName	字符	最多10个字符,不允许重复	职位名称



5、	向PositionMessage添加5个职位信息

INSERT INTO PositionMessage VALUES('1','pg');

INSERT INTO PositionMessage VALUES('2','pl');

INSERT INTO PositionMessage VALUES('3','pm');

INSERT INTO PositionMessage VALUES('4','pt');

INSERT INTO PositionMessage VALUES('5','boss');



SELECT * FROM PositionMessage;



6、	创建表salary，代表工资表，表结构如下

表名salary

字段名	数据类型	其他属性	字段说明

salaryID	整型	主键，自动编号	工资编号

EmployeeID	字符	不允许为空，外键	员工编号

PositionID	字符	不允许为空，外键	职位编号

Wage	整型	不允许为空，默认为0	工资





7、	向salary表中添加8名员工的工资信息，

要求至少有3名员工具有两个职位，添加一些测试数据，验证外键的功能

INSERT INTO salary VALUES(NULL,'emp001','1',88);

INSERT INTO salary VALUES(NULL,'emp001','2',888);

INSERT INTO salary VALUES(NULL,'emp003','2',881);

INSERT INTO salary VALUES(NULL,'emp003','3',882);

INSERT INTO salary VALUES(NULL,'emp005','3',855);

INSERT INTO salary VALUES(NULL,'emp005','4',188);

INSERT INTO salary VALUES(NULL,'emp007','4',288);

INSERT INTO salary VALUES(NULL,'emp009','5',8338);



8、	创建表student，代表学生信息表，表结构如下

表名student

字段名	数据类型	其他属性	字段说明

studentID	整型	不允许为空，主键，自动编号	学生编号

studentName	字符	不允许为空	学生姓名

studentSex	字符	不允许为空，默认为男	学生性别

studentCardID	字符	不允许为空，不允许重复	学生身份证号

studentBirthday	日期时间类型	不允许为空	学生生日





9、	向student表中添加10名学员信息

INSERT INTO student VALUES(NULL,'小张','男','222333200011213344','2000-11-21');

INSERT INTO student VALUES(NULL,'小张2','','222333200011223344','2000-11-22');

INSERT INTO student VALUES(NULL,'小李3','男','222333200011233344','2000-11-23');

INSERT INTO student VALUES(NULL,'小王4','女','222333200011243344','2000-11-24');

INSERT INTO student VALUES(NULL,'小哈5','男','222333200011253344','2000-11-25');

INSERT INTO student VALUES(NULL,'小呵呵6','女','222333200011263344','2000-11-26');

INSERT INTO student VALUES(NULL,'小嘻嘻7','男','222333200011273344','2000-11-27');

INSERT INTO student VALUES(NULL,'小哥儿8','女','222333200011283344','2000-11-28');

INSERT INTO student VALUES(NULL,'小哈哈哈9','男','222333200011293344','2000-11-29');

INSERT INTO student VALUES(NULL,'小小0','女','222333200011203344','2000-11-20');



SELECT * FROM student;



10、	创建表subject，代表课程信息表，表结构如下

表名subject

字段名	数据类型	其他属性	字段说明

subjectID	字符	不允许为空，主键	课程编号

subjectName	字符	不允许为空	学生姓名

teacher	字符	不允许为空	老师姓名

courseCount	整型	不允许为空，默认为0	课时数





11、	向subject表中添加7门课程信息

INSERT INTO SUBJECT VALUES('001','计算机基础','小呵呵',18);

INSERT INTO SUBJECT VALUES('002','计算机网络','小张',18);

INSERT INTO SUBJECT VALUES('003','互联网安全','小李',20);

INSERT INTO SUBJECT VALUES('004','数据分析','小哈哈',22);

INSERT INTO SUBJECT VALUES('005','数据结构','小张',18);

INSERT INTO SUBJECT VALUES('006','软件开发','小李',18);

INSERT INTO SUBJECT VALUES('007','产品设计','小呵呵',16);



SELECT * FROM SUBJECT





12、	创建表grade，代表学生成绩表，表结构如下

表名grade

字段名	数据类型	其他属性	字段说明

gradeID	整型	主键，自动编号	成绩编号

studentID	整型	不允许为空，外键	学生编号

subjectID	字符	不允许为空，外键	课程

score	小数	不允许为空，默认为0	成绩





​	13、向grade表中添加20条成绩

INSERT INTO grade VALUES(NULL,1,'001',88.99);

INSERT INTO grade VALUES(NULL,2,'001',38.99);

INSERT INTO grade VALUES(NULL,3,'001',28.99);

INSERT INTO grade VALUES(NULL,4,'001',68.99);

INSERT INTO grade VALUES(NULL,5,'001',58.99);

INSERT INTO grade VALUES(NULL,6,'001',81.99);

INSERT INTO grade VALUES(NULL,7,'001',48.99);

INSERT INTO grade VALUES(NULL,8,'001',86.99);

INSERT INTO grade VALUES(NULL,9,'001',83.99);

INSERT INTO grade VALUES(NULL,10,'001',98.99);



INSERT INTO grade VALUES(NULL,2,'003',83.99);

INSERT INTO grade VALUES(NULL,5,'002',54.99);

INSERT INTO grade VALUES(NULL,8,'006',75.99);

INSERT INTO grade VALUES(NULL,2,'003',86.99);

INSERT INTO grade VALUES(NULL,3,'004',43.99);

INSERT INTO grade VALUES(NULL,5,'006',55.99);

INSERT INTO grade VALUES(NULL,8,'007',68.99);

INSERT INTO grade VALUES(NULL,8,'002',23.99);

INSERT INTO grade VALUES(NULL,4,'003',64.99);

INSERT INTO grade VALUES(NULL,3,'005',44.99);



SELECT * FROM grade;





# 练习2



向数据库中导入表job.xls，完成如下功能

一、数据的添加修改删除

1、	导入数据成功之后，按照下述要求修改表结构，字段功能如下：本表存储了某公司收到的求职者信息

id-序号  

recDate-投递简历日期  

source-简历来源 51job 大连快线 智联招聘 大连人才 

position-职位 咨询顾问,市场专员,美工,咨询师,网络推广,网络推广员

name-求职者姓名 

age-求职者年龄 

tel-求职者电话

 

1.	向表中添加5记录，要求所有简历投递日期字段均为今天日期，

其中，包含3条电话号码为空的记录

INSERT INTO job VALUES(null,NOW(),'智联招聘','美工','小红',88,'13312344321');

INSERT INTO job VALUES(null,NOW(),'大连快线','市场专员','张三',23,'13312344322');

INSERT INTO job VALUES(null,NOW(),'大连人才','咨询师','李四',33,NULL);

INSERT INTO job VALUES(null,NOW(),'51job','网络推广','王五',25,NULL);

INSERT INTO job VALUES(null,NOW(),'智联招聘','咨询顾问','小明',26,NULL);



SELECT * FROM job ORDER BY id DESC;



2.	将所有求职者的年龄加1岁

UPDATE job SET age = age+1;



3.	本公司不打算面试来路不明的求职者，请删除简历来源为“未知”的求职者信息

id=153 是未知来源

DELETE FROM job WHERE source = '未知'



4.	“咨询师”与“咨询顾问”本为一个职位，

顾公司欲将表中职位为“咨询师”的改为“咨询顾问”，

统一职位名称，请使用SQL命令实现该功能

UPDATE job SET position = '咨询顾问' WHERE position = '咨询师';

SELECT * FROM job;



5.	本公司不打算录用男性咨询师，请删除不符合要求的信息

DELETE FROM job WHERE position = '咨询顾问' and sex = '男';

SELECT * FROM job WHERE position = '咨询顾问' ;



6.	没有留下电话的求职者，无法约访面试，请删除所有未留电话的求职者信息

DELETE FROM job WHERE tel = '' or tel is NULL;

SELECT * FROM job WHERE position = '咨询顾问' ;



7.	本公司不打算录用年龄在30-34岁之间的咨询顾问，请删除不符合要求的信息

DELETE FROM job where (age BETWEEN 30 AND 34) AND position = '咨询顾问';

SELECT * FROM job WHERE (age BETWEEN 30 AND 34) AND position = '咨询顾问';



8.	本公司的“PHP实习生”、“ 美工”、“校园代理”职位已满，不打算再约面试，

请删除这几种职位的求职者信息

SELECT * FROM job WHERE position IN ('PHP实习生','美工','校园代理');

DELETE FROM job WHERE position IN ('PHP实习生','美工','校园代理');



二、根据job表，完成如下查询：

9.	查询求职“市场专员”职位的求职者简历来源、姓名、性别、职位

SELECT source 来源, name 姓名, sex 性别, position 职位 FROM job WHERE position='市场专员';



10.	查询7月份收到的简历信息，显示求职者职位、姓名、年龄、电话

SELECT recdate 日期,position 职位, name 姓名, age 年龄,tel 电话 FROM job WHERE recdate BETWEEN '2010-07-01' AND '2010-07-31';



11.	查询年龄在20-23岁之间的

求职 咨询顾问 的

女性求职者 有哪些人，

显示职位、姓名、年龄、性别

SELECT position 职位, name 姓名,age 年龄 ,sex 性别 

FROM job 

WHERE (age BETWEEN 20 AND 23) AND position = '咨询顾问' AND sex = '女' ;





12.	查询电话号码为158开头，且尾号为8的求职者信息，显示姓名、职位、电话

SELECT name 姓名 , position 职位, tel 电话

FROM job 

WHERE tel LIKE '158%' AND tel LIKE '%8';



13.	查询来自于智联招聘和大连快线的求职网络推广的有哪些人，显示简历来源、

姓名、职位

SELECT source 来源, name 姓名 , position 职位

from job 

where source IN ('智联招聘','大连快线');



14.	查询求职实习生的有哪些人，显示简历来源、姓名、职位、年龄

SELECT source 来源, name 姓名 , age 年龄

FROM job

WHERE position = '实习生';



15.	查询没有电话的求职者信息，显示姓名、职位、年龄、电话

SELECT name 姓名 , position 职位 , age 年龄 , tel 电话 

FROM job

WHERE tel = '' or tel is null;

# 练习3





向数据库中导入company.xls文件中的表



二、使用employees表和department表做查询操作

1．	查询所有员工的信息，并将查询结果中的每个列的列名起一个中文的别名



SELECT emp_id 编号, emp_name 姓名, emp_cardid 工号,emp_wage 基本工资, emp_salary 奖金,

emp_city 城市, com_id 部门, emp_date 入职日期

FROM employees;



SELECT * FROM employees;

SELECT * FROM department;



2．	查询c03部门的员工有哪些人

select * from employees where com_id = 'c03';



3．	查询工资总额（基本工资+奖金）在4000-7000之间的员工信息

select * from employees where emp_wage + emp_salary BETWEEN 4000 and 7000 

order by emp_wage;



4．	查询来自大连，沈阳和北京的员工信息

select * 

from employees 

where emp_city in ('大连','沈阳','北京');



5．	查询来自未知城市的员工

SELECT *

from employees

where emp_city is null;



6．	查询2000年以后入职的员工信息

SELECT *

from employees

where emp_date > '2000-1-1'

order by emp_date;



7．	查询姓王的员工信息

select *

from employees

where emp_name like '王%';



8．	查询人事部的负责人是谁

select com_manager

from department

where com_name = '人事部';



9．	查询c05部门的员工来自哪几个城市

select emp_city

from employees

where com_id = 'c05'

group by emp_city;



10．	查询c03部门来自大连的员工有哪些人

select *

from employees

where com_id = 'c03' and emp_city = '大连';





向数据库中导入pubs.xls文件中的表，完成如下查询

三、使用titles表、sales表做查询

titles（图书标题）表字段：

 title_id（图书编号），title（标题名），type（类型），price（价格），pubdate（出版日期）

sales（销售）表字段：

 ord_num（订单编号），ord_date（订购日期），qty（订购数量），payterms（付款方式）

​	



1．	查询标题中含有“of”的图书信息

select * from titles where title like '%of%';



2．	查询出版日期在1991年6月份的图书信息

select * from titles where pubdate BETWEEN '1991-6-1' and '1991-6-30';



3．	查询类型是psychology的图书信息

select * from titles where type = 'psychology';



4．	显示出1994年9月份的订单信息

select * from sales where ord_date BETWEEN '1994-9-1' and '1994-9-30';



5．	显示出销售数量为20的图书信息

select t.* ,sum(qty) 销售总数

from titles t,sales s

where t.title_id = s.title_id 

GROUP BY t.title_id

HAVING sum(qty) = 20;

# 练习4

一、根据job表，完成如下查询：命令写在job_tb中

1.	查询本公司都招聘哪些职位

select position from job GROUP BY position;



2.	查询本公司的简历都通过哪些途径获取

select source from job GROUP BY source ;



3.	在求职市场专员职位的男性求职者中，显示出最年轻的前10位求职者信息

SELECT * 

FROM (

​	select *

​	from job

​	where sex = '男'

​	ORDER BY age

) emps limit 10;



4.	查询本公司一共收到多少份简历

select count(*) from job;



5.	查询每个招聘途径收到多少份简历

select source , count(*)

from job

GROUP BY source



6.	查询求职“市场专员”职位的男女求职者分别多少人

select sex , count(*)

from job

GROUP BY sex;



7.	查询哪种招聘途径收到的咨询顾问简历最多

select source , count(*)

from job 

where position = '咨询顾问'

GROUP BY source

ORDER BY count(*) desc;



8.	查询年龄在22-28岁之间的求职者中，每个职位有多少人感兴趣，将结果按照人数由多到少显示

select position,count(*)

from job

where age BETWEEN 22 and 28

GROUP BY position

ORDER BY count(*) desc;



9.	收到简历在20份以上的招聘途径分别是哪些

select source , count(*)

from job

GROUP BY source

HAVING count(*) > 20

order by count(*) desc; 



10.	查询本公司招聘多少个职位

注意！！！！！：必须有别名 positions

select count(*) 职位数

from (

​	SELECT position 

​	from job

​	GROUP BY position

) positions



11.	显示哪个两个职位最受欢迎

SELECT *

from (

​	select position , count(*)

​	from job

​	GROUP BY position

​	ORDER BY count(*) desc

) positions LIMIT 2 ;



12.	显示哪个月份收到的简历数最多

select month(recdate) , count(*)

from job

GROUP BY month(recdate)

order by count(*) desc;



13.	显示女性求职者中，每个职位的求职者平均年龄是多少岁

select position , ROUND(avg(age))

from job

where sex = '女'

GROUP BY position;



select position , avg(age)

from job

where sex = '女'

GROUP BY position;



14.	显示投递市场专员职位的求职者中，男女求职者的最大年龄分别是多少岁

SELECT sex , max(age)

from job

GROUP BY sex;



二、使用employees表和department表做查询操作 作业结果在employees里面



1．	查询工资总额最高的员工信息

select *

from employees

ORDER BY (emp_wage + emp_salary) desc LIMIT 1;



2．	查询c02部门获得奖金最高的员工是谁

select *

from employees

where com_id = 'c02'

ORDER BY emp_salary desc LIMIT 1;



3．	查询所有员工的信息，将信息按照基本工资从高到低显示，当基本工资相同时，按照员工的入职日期由晚到早来显示

select *

from employees

ORDER BY emp_wage desc,emp_date desc;



4．	查询显示出所有员工的基本工资总和，基本工资平均值，最高工资和最低工资，给每个结果列都要起一个别名

SELECT sum(emp_wage) 工资总和, avg(emp_wage) 平均工资, max(emp_wage) 最高工资, min(emp_wage) 最低工资

from employees;



5．	查询销售额最高的部门编号

SELECT com_id

from department

where com_total = (

​	SELECT max(com_total)

​	from department

);





6．	根据employee表查询出本公司有几个部门

SELECT count(*)

from (

​	SELECT com_id

​	from employees

​	GROUP BY com_id

) comid;



7．	查询出本公司的员工来自几个城市

SELECT count(*)

from (

​	SELECT emp_city

​	from employees

​	where emp_city is not null

​	GROUP BY emp_city

) city;



8．	查询哪个部门的平均工资最高

SELECT com_name

from department

WHERE com_id = (

​	SELECT com_id

​	from(

​		SELECT com_id

​		from employees

​		GROUP BY com_id

​		ORDER BY avg(emp_wage) desc

​	) comid LIMIT 1

);



9．	查询来自每个城市的员工分别有多少人

SELECT emp_city,count(*)

from employees

GROUP BY emp_city



10．	查询显示该公司每个城市的员工平均工资

SELECT emp_city , avg(emp_wage + emp_salary)

from employees

GROUP BY emp_city;



11．	在基本工资高于2000元的员工中，

查询每个部门的员工平均工资，

并显示出部门平均工资高于4000元的记录，

按照平均工资由低到高显示

SELECT com_id,avg(emp_wage)

FROM employees

where emp_wage > 2000

GROUP BY com_id

HAVING avg(emp_wage) > 4000

order by avg(emp_wage) asc;



12．	查询部门人数超过6个人的部门编号

SELECT com_id , count(*)

from employees

GROUP BY com_id

HAVING count(*) > 6;



13．	查询每个部门的最高奖金为多少钱

SELECT d.com_name,max(e.emp_salary)

FROM employees e INNER JOIN department d ON e.com_id = d.com_id

GROUP BY d.com_name;



# 练习5

1、	根据如下表结构使用SQL命令创建表：ordertb，字段说明如下：



1）	orderID：订单号 int 11 k

2）	webName：订购商平台 varchar 30

3）	productName：商品名称 varchar 50

4）	productType：商品类别 varchar 30 null

5）	orderCount：订单数量 int 11

6）	oderDate：订单日期 datetime

7）	agent：代理商 varchar 30



CREATE TABLE ordertb (

​	orderid int(11) PRIMARY KEY,

​	webname varchar(30) not null,

​	productname varchar(50) not null,

​	productype varchar(30),

​	ordercount int(11) not null,

​	orderdate datetime not null,

​	agent varchar(30) not null

);



 



2、将order.xls文件中的数据导入到数据库的ordertb表中 

答案在order_tb中



3、完成如下查询

1） 查询订单总数超过5000的有哪些商品

select productname , sum(ordercount)

from ordertb

GROUP BY productname

HAVING sum(ordercount) > 5000

ORDER BY sum(ordercount);



2） 查询每个订购商都订购了多少次商品

select agent , count(*)

from ordertb

GROUP BY agent

order by count(*);



3） 查询每个代理商订购的商品总额

SELECT agent , sum(ordercount)

from ordertb

GROUP BY agent;



4） 将每个订购商订购的商品数量由多到少显示出来

SELECT agent , sum(ordercount)

from ordertb

GROUP BY agent

order by sum(ordercount) desc;



5） 显示每天每件商品的订购数量

select pdo.pn , pdo.dt , sum(pdo.oc)

from (

​	SELECT productname pn, DATE(orderdate) dt, ordercount oc

​	from ordertb

) pdo

GROUP BY pdo.pn,pdo.dt;



6） 显示每个订购商订购的每件商品的总数

select agent , productname , sum(ordercount)

from ordertb

GROUP BY agent , productname;



7） 显示订购数量最多的商品

SELECT productname , sum(ordercount)

from ordertb

GROUP BY productname

ORDER BY sum(ordercount) desc

limit 1;



8） 显示订货最多的订购商

SELECT agent , sum(ordercount)

from ordertb

GROUP BY agent 

order by sum(ordercount) desc

limit 1;



9） 显示订购数量最多3天

SELECT DATE(orderdate) dt, sum(ordercount) oc

from ordertb

GROUP BY date(orderdate)

order by oc desc

limit 3;



10） 查询都有哪些订购商订购了电子产品

select agent

from ordertb

where producttype = '电子产品'

GROUP BY agent;



11） 查询牙膏的每天订货量，按照订货量由高到低显示

SELECT date(orderdate) , sum(ordercount)

from ordertb

where producttype = '牙膏'

GROUP BY date(orderdate)

order by sum(ordercount) desc;



12） 查询哪个月份的订货量最多

SELECT month(orderdate),sum(ordercount)

from ordertb

GROUP BY month(orderdate)

ORDER BY sum(ordercount) desc

limit 1;





# 练习6



使用job表实现完成如下查询     答案在job_tb查询中





1、	查询与“罗曼”求职同一职位的还有哪些人

select *

from job

where position = (

​	SELECT position

​	from job

​	where name = '罗曼'

);



2、	查询哪些求职者的年龄高于所有求职者的平均年龄

SELECT *

from job

where age >(

​	SELECT round(avg(age))

​	from job

)

order by age;



3、	查询最受欢迎的职位有哪些求职者感兴趣

SELECT *

from job

where position = (

​	SELECT position

​	from job

​	GROUP BY position

​	order by count(*) desc

​	limit 1

);



4、	查询与“王亮”同一天面试的还有哪些人

SELECT *

from job

where recdate = (

​	SELECT recdate

​	from job

​	where name = '王亮'

)



5、	查询哪些职位比“网络推广”职位更受欢迎

SELECT position 职位 , count(*)

from job

GROUP BY position

HAVING count(*) > (

​	SELECT count(*)

​	from job

​	where position = '网络推广'

)



使用employees表、department表完成如下查询   答案在employees查询中



SELECT * from employees;

SELECT * from department;

1．	查询出来自大连所有员工的信息，显示出员工的姓名，所在部门，工资总和



select emp_name 姓名,d.com_name 部门,emp_wage + emp_salary 总工资

from employees e INNER JOIN department d

on e.com_id = d.com_id

where emp_city = '大连'



2．	查询人事部门的所有员工信息，显示员工姓名，城市，基本工资和奖金（只允许使用嵌套查询）



SELECT emp_name 姓名,emp_city 城市,emp_wage 基本工资,emp_salary 奖金

from employees

where com_id = (

​	select com_id

​	from department

​	where com_name = '人事部'

)



3．	查询employees表中工资低于所有员工平均工资的员工信息，显示员工姓名，工资字段



select emp_name , emp_wage

from employees

order by emp_wage

limit 1



4．	查询employees表中比“冰红茶”入职晚的所有员工的信息，显示员工姓名，入职日期字段



select emp_name , emp_date

from employees

where emp_date > (

​	select emp_date

​	from employees

​	where emp_name = '冰红茶'

)

order by emp_date



5．	查询employees表中获得最高奖金(emp_salary)的员工信息，显示员工姓名，奖金字段。



SELECT emp_name , emp_salary

from employees

order by emp_salary desc

limit 1



6．	查询部门经理是“王九”的部门中所有员工信息，显示员工姓名，部门编号



select emp_name 姓名, e.com_id 部门编号

from employees e INNER JOIN department d

on e.com_id = d.com_id

where com_manager = '王九'



7．	查询和张三处在同一部门的所有员工的姓名。



SELECT e.emp_name

from employees e , department d

where e.com_id = d.com_id and e.com_id =(

​	select com_id

​	from department

​	where com_manager='张三'

)



8．	查询哪个部门的员工工资总额最高，显示该部门的名称及经理。



select com_name , com_manager 

from employees e inner join department d

on e.com_id = d.com_id

GROUP BY e.com_id

order by sum(emp_wage) desc

limit 1



9．	查询工资最高的员工来自哪个部门，显示员工的姓名，所在部门的名称，经理名字及工资数额



select emp_name , com_name ,com_manager , emp_wage

from employees e inner join department d

on e.com_id = d.com_id

order by emp_wage desc

limit 1



10．	按照部门人数由高到低显示出每个部门的名称、人数、部门负责人



select com_name 部门, count(*) 人数, com_manager 负责人

from employees e inner join department d

on e.com_id = d.com_id

GROUP BY e.com_id

order by count(*) desc



11．	显示出总销售额（com_total）最高的部门有哪些员工



select *

from employees

where com_id = (

​	select com_id

​	from department

​	order by com_total desc

​	limit 1

)



12．	查询哪个城市的员工最多，列出该城市的所有员工信息



select *

from employees

where emp_city = (

​	select emp_city

​	from employees

​	GROUP BY emp_city

​	order by count(*) desc

​	limit 1

)



13．	查询哪个部门的平均年龄最大，显示出该部门的名字



SELECT com_name

from employees e inner join department d

on e.com_id = d.com_id

GROUP BY e.com_id

order by avg(emp_date) desc

limit 1



导入join.xls文件



使用emp表、salary表、posMess完成如下查询 答案在join查询中



1．	查询每个员工的姓名，职位和工资情况

select * from salary;

select * from emp;

select * from posmess;



select e.employeeName 姓名, p.positionName 职位,s.wage 工资情况

from emp e,salary s,posmess p

where e.employeeID = s.employeeID ,s.position = p.positionID



select empname 姓名, p.positionName 职位,wage 工资情况

from posmess p , (

​	select e.employeeName empname, s.wage wage,s.position pid

​	from emp e,salary s

​	where e.employeeID = s.employeeID

) es

where p.positionID = es.pid



2．	查询职位是“Teacher”的员工包括哪些，显示员工姓名，工资



select empname 姓名,wage 工资情况

from posmess p , (

​	select e.employeeName empname, s.wage wage,s.position pid

​	from emp e,salary s

​	where e.employeeID = s.employeeID

) es

where p.positionID = es.pid and p.positionName='Teacher'



3．	查询电话号为空的员工是什么职位，显示员工姓名和职位名称

-- 数据不全！！

SELECT e.employeeName , p.positionName ,e.employeeTel

from emp e,salary s,posmess p 

where e.employeeID = s.employeeID and s.position = p.positionID and e.employeeTel is null





4．	查询出所有员工的基本信息及工资信息，显示员工编号，员工姓名，

所处职位名称，工资数额，没有工资的员工只显示员工的编号和姓名



SELECT e.employeeID , e.employeeName , sp.positionName , sp.wage

from emp e left JOIN (

​	SELECT *

​	from salary s, posmess p

​	where s.position = p.positionID

) sp

on e.employeeID = sp.employeeID





5．	查询工资总额（基本工资+奖金）最高的员工叫什么



select e.emp_name

from employees e

order by (e.emp_wage + e.emp_salary) desc

limit 1



6．	查询哪个职工目前还没有分配职位





SELECT e.employeeName , sp.positionName

from emp e left JOIN (

​	SELECT *

​	from salary s, posmess p

​	where s.position = p.positionID

) sp

on e.employeeID = sp.employeeID

where sp.positionname is null







7．	查询出最年长的员工是什么职位，工资多少钱



SELECT sp.positionname , sp.wage

from emp e left JOIN (

​	SELECT *

​	from salary s, posmess p

​	where s.position = p.positionID

) sp

on e.employeeID = sp.employeeID

order by e.employeeage desc

limit 1





# 0 MySQL说明

Mysql 中int的长度，只是表示显示的长度，参考：

https://blog.csdn.net/lihuanlin/article/details/89145722





Mysql 常用方法： https://blog.csdn.net/lhs19940203/article/details/83009043





主键间断自增长，参考：



 

**mysql数据库镜像** https://blog.csdn.net/iteye_8381/article/details/81804490



主键用uuid还是int自增长，参考：

https://blog.csdn.net/qq_23994787/article/details/90289743



mysql中 varchar类型说明：

https://www.cnblogs.com/zwsblogs/p/11276087.html



Mysql生成uuid：

https://www.cnblogs.com/XiaoZhengYu/p/12933521.html



## （1）数据库层级



Database（数据库）-> Datatable（表）-> data（数据）





## （2）工作流程：

​	1. mysql服务端先启动，监听在某一个特定的端口（3306）

​	2. mysql客户端连接服务端

​	3. mysql客户端就可以发送相关的操作命令，去操作服务端存储的数据





## （3）MySQL数据类型

整型：Int

浮点型：Float

字符串：VARCHAR(n)（字符串需要定长度）

大文本：Blob/longblob

日期时间：DATETIME





## （4）MySQL数据表的约束

- 约束用来限制存储数据的准确性
- 可以在创建表时规定（通过CREATE TABLE），或创建后规定（通过ALTER TABLE 语句）

**常见的约束：**

- NOT NULL - 非空约束：不可存NULL值，不可不存值
- UNIQUE - 唯一约束：不可有重复值出现
- PRIMARY KEY - 主键约束：前两个约束的结合
- FOREIGN KEY - 外键约束：保证该列中的数据匹配另一个表中数据的参照完整性（不许依赖不存在的实体）
- CHECK - 检查约束：保证列中的值符合指定的条件
- DEFAULT - 默认约束：用于插入默认值





## （5）数据库事务(安全)

事务的概念：一组SQL语句的操作单元、这些SQL语句是一个整体业务功能、要么都执行成功、要么都执行失败。

事务的概念：用户的一次请求就是一个事务。是一个不可分割的工作单位。



**举例：银行转账的事务。**

UPDATE bank set money = money-100 WHERE name = '李四';

UPDATE bank set money = money+100 WHERE name = '张三';

问题：怎么保证这个事务的一些列SQL语句是一个单元？怎么保证都执行、或都不执行。



**演示：**Mysql数据库为例

**说明：**mysql数据库的事务默认是自动提交的。



事务提交：把数据真正存储到表中。



演示事务自动提交的过程



由于事务是一组SQL语句的单元、这些SQL语句只有我们程序员知道哪些SQL是一个事务、因此在项目中事务需要设置为非自动提交。



- 注意：事务自动提交必须改为手动提交。否则



**希望：**



设置事务为非自动提交(手动提交、该事务是否提交由程序员来决定)

UPDATE bank set money = money-100 WHERE name = '李四';	成功

UPDATE bank set money = money+100 WHERE name = '张三'; 成功



如果所有SQL语句都执行成功则事务提交/如果其中SQL语句有执行失败的则事务回滚(回到数据初始状态)



事务提交：commit

事务回滚：rollback



**查看事务状态**

show variables like '%autocommit%';



**设置事务为手动提交**

set @@autocommit = 0;



**设置事务为自动提交**

set @@autocommit = 1;



# 0 存储引擎



参考： https://www.cnblogs.com/sunsky303/p/8274586.html





- 5.1之前默认MyIsam，之后默认InnoDB
- 5.6之后InnoDB支持事务



InnoDB和MyIsam主要区别

- 前者支持事务，后者不支持
- 前者支持外键，后者不支持
- 前者能恢复数据库，后者不能

# 1 MySQL 常用操作

##  



## （0）查看终端中mysql历史操作记录

终端：



open ~/.mysql_history



## （1）终端进入数据库操作界面：



mysql -u root -p



**输入密码后即可进入数据库**





## （2）退出MySQL操作界面：



quit;





## （3）查询版本号：



select versioin();





## （4）查找数据库文件位置使用命令



show global variables like "%datadir%";

![Screen Shot 2020-09-19 at 11.18.30.png](/blob:file:/d151da71-258d-4b7e-911f-753ac178a091)



## （5）操作数据库  



**创建数据库：**

- create database 数据库名称 charset utf8;

- 命名规范：

- - 可以由字母、数字、下划线、＠、＃、＄
  - 区分大小写
  - 唯一性
  - 不能使用关键字如 create select
  - 不能单独使用数字
  - 最长128位



CREATE DATABASE dbname;

​		

show create database 数据库名;



**删数据库：**



drop database 数据库名称;



**改数据库：**

- 删除再添加
- 如果数据库中有数据的话，直接drop会导致数据库中的数据丢失
- 在线上环境，不能够直接删除数据， 在删除之前，需要进行备份

​		

**查** 数据库：



show databases;



**使用数据库：**



use 数据库名;



**创建表：**



CREATE TABLE table_name;











## 增

INSERT INTO TABLE VALUES(id,name,age);



## 改

UPDATE TABLE SET name = '123' WHERE id = 1;



## 删

DELETE FROM TABLE WHERE id = 1;



##  查

SELECT *

FROM TABLE

WHERE id = 1

GROUP BY sex

HAVING age > 11

ORDER BY date

LIMIT 0,1 ;



## 左连接、右连接和内连接



FROM A LEFT JOIN B ON A.ID = B.ID

FROM A LEFT OUTER JOIN B ON A.ID = B.ID



FROM A RIGHT JOIN B ON A.ID = B.ID

FROM A RIGHT OUTER JOIN B ON A.ID = B.ID



FROM A INNER JOIN B ON A.ID = B.ID





# 1 MySQL基本SQL语句

- sql语句不区分大小写、但数据区分大小写



## (1)添加语句

- 关键字：insert into



- 无指定列：



INSERT INTO talbe_name VALUES (value1,value2,value3,…);



- 指定列：



INSERT INTO table_name(column1,column2,column3,…) VALUES (value1,value2,value3,…);



- 插入多条：



INSERT INTO table_name(column1,column2,column3,…) VALUES

(value1,value2,value3,…),

(value1,value2,value3,…),

(value1,value2,value3,…);





## （2）修改语句

- 关键字：update set



UPDATE table_name SET column1=value1,column2=value2,…

WHERE some_column=some_value;





## （3）删除语句

- 关键字：delete



DELETE FROM table_name WHERE some_column=some_value;





## （4）查询语句

- 关键字：select from



- 查询表所有列（不建议，尤其是数据量大时）



SELECT * FROM table_name;



- 查询指定列



SELECT column_name1,column_name2 FROM table_name;



- 带条件的查询



SELECT column_name1,column_name2

FROM table_name

WHERE some_column=some_value;





## （5）运算符



\>、>=、<、<=、=、!=





## （6）逻辑

- 关键字：and、or



WHERE column_name1 = value1 AND column_name2 = value2

WHERE column_name1 = value1 OR column_name2 = value2



## （7）区间

- 关键字：between and、not between and



BETWEEN value1 AND value2 、 NOT BETWEEN value1 AND value2





## （8）集合

- 关键字：in、not in



WHERE column_name1 IN(value1,value2,…) 

WHERE column_name1 NOT IN(value1,value2,…)





## （9）模糊查询

- 关键字：like
- 通配符：“_”匹配一个任意字符、”%“匹配0个或多个字符



WHERE name like '王_';

WHERE name like '王%';

WHERE name like '%王%';





## （10）空

- 关键字：null
- 表示空的意思、未知或没有数据
- 不是0，不是空字符串
- 必须搭配is、not is使用



WHERE value1 IS NULL;

WHERE value2 NOT IS NULL;





## （11）分组查询

- 关键字：group by
- 理解：相同的为一组，结果按组来显示记录，有几组就显示几条记录
- 注意：分组时，select显示的字段有约束条件，即一是分组的组名、二是聚合函数



SELECT sex FROM person GROUP BY sex;



SELECT sex, MAX(age) 最大, MIN(age) 最小, COUNT(*) 个数, SUM(*) 求和, AVG(age) 平均

FROM person

GROUP BY sex;





## （12）组过滤语句

- 关键字：having
- 注意：where和having都是条件语句
- 注意：where时每条记录进行过滤筛选
- 注意：having时对分组后的数据进行过滤筛选。所以，必须在分组之后才能使用having



- 查询哪个城市的男员工数大于10：

SELECT city, count(*) c

FROM employee

WHERE sex='男'

GROUP BY city

Having c > 10;





## （13）排序

- 关键字：order by

- 排序方式：

- - asc：正序、升序
  - desc：倒序、降序

- 说明：order by 后修饰的字段，为查询后表中的字段

- 注意：order by 必须在所有查询条件之后、默认排序为正序



- 默认按升序排序



SELECT * FROM person ORDER BY age;



- 升序



SELECT * FROM person ORDER BY age ASC;



- 降序



SELECT * FROM person ORDER BY DESC;





## （14）连接

- 关键字：

- - 左连接：LEFT JOIN
  - 右连接：RIGHT JOIN
  - 内连接（等值连接）：INNER JOIN

- 搭配on使用

- 左连接：获取左表中所有数据，即使右表没有匹配的记录

- 右连接：与左连接相反，获取右表中所有记录，即使左表中没有匹配

- 内连接：两表都有匹配才返回行

- 全连接：只要其中一个表中存在匹配，则返回行



- 每个职位的员工信息，即使没有员工，也要查出来职位信息，使用**左连接**查询：



SELECT pos.name 职位, emp.*

FROM position pos LEFT JOIN employee emp

ON pos.pid = emp.pid



- 每个职位都有哪些员工，即使没有员工，也要查出来，使用**右连接**查询：



SELECT pos.name 职位, emp.*

FROM employee emp RIGHT JOIN position pos

ON pos.pid = emp.pid



- 查询所有员工信息，包括职位名称，没有员工的职位不显示，使用**内连接**查询：



SELECT pos.name 职位, emp.*

FROM employee emp INNER JOIN position pos

ON pos.pid = emp.pid





## （15）合并

- 关键字：UNION、UNION ALL
- UNION 合并的查询语句，必须拥有一样数量、顺序、数据类型的列
- UNION 选取不同的行进行合并，自动屏蔽重复数据。
- UNION ALL 允许重复的值



SELECT column_name(s) FROM table1

UNION

SELECT column_name(s) FROM table2;





## （16）复制

- 关键字：INSERT INTO SELECT
- 复制一个表中数据，插入另一已存在表中。目标表中已存在行都不会受影响



**复制全部字段：**



INSERT INTO table2 SELECT * FROM table1;



**复制指定字段：**



INSERT INTO table2(column_name(s)) 

SELECT column_name(s) FROM table1;





## （17）分页查询

- 关键字：LIMIT
- LIMIT n：n代表取出前n行记录
- LIMIT n,m：n代表起始行数（结果不包含该行），m代表取出行数



SELECT * FROM orders_history LIMIT 20,5;





## （18）子查询

- 子查询可以用在不同的子句中



**子查询用在条件语句中：**



SELECT * FROM PERSON

WHERE deptno in

(SELECT deptno FROM dept);





## （19）正则表达式

- 关键字：regexp
- 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。
- 可组合使用

| 模式        | 描述                                          | 举例                     | 匹配           |
| ----------- | --------------------------------------------- | ------------------------ | -------------- |
| 一些字符    | 匹配包含字符串                                | name REGEXP 'ab'         | aaab或ab或abcc |
| ^           | 匹配字符串开始的位置                          | name REGEXP '^ab'        | ab或abz        |
| $           | 匹配字符串结束位置                            | name REGEXP 'ab$'        | ab或sab        |
| .           | 匹配除了\n之外的任何字符，如需匹配\n可用[.\n] | name REGEXP 'a.b.'       | acbc或asbd     |
| [一些字符]  | 字符集合，匹配包含的任意字符                  | name REGEXP '[abc]'      | apple或plain   |
| [^一些字符] | 负值字符集合，匹配未包含的任意字符            | name REGEXP '[^abc]'     | code或window   |
| p1\|p2\|p3  | 匹配p1或p2或p3                                | name REGEXP '(b\|c)lass' | blass或class   |
| *           | 匹配*前面的子表达式0次或多次                  | name REGEXP 'pa*'        | p或paaaa       |
| +           | 匹配+前面的子表达式1次或多次                  | name REGEXP 'pa+'        | pa或paaaaa     |
| {n}         | n为非负整数，表示确定匹配几次                 | name REGEXP 'p{2}'       | app或apple     |
| {n,m}       | m和n均为非负整数，其中n<=m。表示匹配n到m次    | name REGEXP 'p{1,2}'     | plane或app     |

# 2 MySQL安装及说明





## (一)安装环境

**(1)Mysql**数据库服务器(安装、卸载)

- 注意1：端口3306
- 注意2：密码123456
- 注意3：编码UTF-8
- 注意4：卸载完成之后、C盘mysql删除、ProgramData下mysql删除

**(2)Navicat(**客户端软件)





## (二)Mysql常用命令



**查看数据库**

show databases;



**创建数据库**

create database db0803;



**使用数据库**

use db0803;



**查看表**

show tables;



**创建表**

create table t1(

id int(10),

name varchar(20),

money double(5,2)

);



**删除表**

drop table t1;



**删除数据库**

drop database db0803;





## (三)数据库

**关系型数据库**(SQL)：Mysql(主)、Oracle

**非关系型数据库**(NOSQL)：Redis





## (四)navicat中导入导出操作

- **SQL导出、导入**
- **Excel导出、导入**
- **注意：表名、字段类型**





## (五)SQL语句

- **Mysql数据库：服务器 -> 数据库 -> 表 -> 数据(添加、修改、删除、查询)**
- **SQL:结构化查询语言。是关系型(数据以表的形式存储)数据库的语言。**
- **SQL语句句式：insert添加、update修改、delete删除、select查询(难)。**





## (六)SQL语句单表添加、修改、删除、查询

**insert**添加

**update**修改

**delete**删除

**select**查询





## (七)SQL语句多表查询

**注意：多表没有添加、没有修改**(级联修改)、没有删除(级联删除)。

**(1)**多表连接

**(2)**子查询





## (八)主键、外键

**单表设计：用主键**

**多表设计：用外键**(推荐：由多的一方来维护、多的一方添加外键、多的记少的)



**comid**：公共列、两张表都有的列

# 3-1 单表SQL语句



## （一）添加语句

**（**1）添加全部字段

INSERT INTO person VALUES(null,'张三',7,'男',3000.44,'2020-1-31','2020-8-3 11:13:23');

INSERT INTO person VALUES(null,'张三',9,'男',3000.44,NOW(),NOW());



**（**2）添加部分字段

INSERT INTO person(id,name) VALUES(null,'王五');

INSERT INTO person(sex,id,age,name) VALUES('男',null,9,'王五');



## （二）修改语句

UPDATE person SET name='小站' , age = 999 where id=1

UPDATE person SET name='小站' , age = 999 where name='张三'



## （三）删除语句

DELETE FROM person where id = 1



## （四）查询语句



**1.SELECT			显示**

**2.FROM			表**

**3.WHERE			条件**

**4.GROUP BY		分组**

**5.HAVING		组过滤**

**6.ORDER BY		排序**

**7.LIMIT			抽取**



**1.SELECT** 用来显示字段

SELECT * FROM person;

SELECT name,sex FROM person ;

SELECT name 名字, sex 性别, age 年龄 FROM person;

SELECT (age+1) ageAdd FROM person ;



**2.FROM** 用来指定表

SELECT * FROM person ;

​	SELECT person.* from person;

SELECT * FROM person per;

​	SELECT per.* FROM person per;

SELECT per.name 姓名, per.age+1 年龄, per.sex 性别 FROM person per;



**3.WHERE** 条件

比较运算符6个

​	SELECT * FROM person WHERE age > 9;

​	SELECT * FROM person WHERE age >= 9;

​	SELECT * FROM person WHERE age < 9;

​	SELECT * FROM person WHERE age <= 9;

​	SELECT * FROM person WHERE age = 9;

​	SELECT * FROM person WHERE age != 9;

逻辑运算符3个 AND OR NOT( is not 、not like 、not in )

​	SELECT * FROM person WHERE age >=8 AND age<=10;

​	SELECT * FROM person WHERE name = '张三去' OR name = '张三二';

其他运算符

BETWEEN AND 查询连续数字区间

​	SELECT * FROM person WHERE age BETWEEN 8 AND 10;

IN （集合） 查询不连续区间

​	SELECT * FROM person WHERE name IN ('张三去','张三二');

LIKE 匹配符 模糊查询

​	% 表示0或多个任意字符

​	_ 表示1个任意字符

​	SELECT * FROM person WHERE name like '%张三_';

​	SELECT * FROM person WHERE name like '张%';

​	SELECT * FROM person WHERE name like '张_';

NULL 在数据库中表示 空、未知 的意思

注意：不是 0 也不是 空字符串

注意：null判断必须和is连用，不能用=

​	SELECT * FROM person WHERE money IS NULL;

​	SELECT * FROM person WHERE money IS NOT NULL;



**4.GROUP BY** 分组显示（字段的值相同的就是一组、相同的有几组就显示几条记录。）

注意：按照某个字段分组、select 后的字段必须是分组的组名 或者 聚合函数

SELECT sex FROM person GROUP BY sex;

SELECT name FROM person GROUP BY name;

聚合函数：count、max、min、sum、avg

SELECT sex,COUNT(*),MAX(age) 最大值,MIN(age) 最小值

FROM person

GROUP BY age;

SELECT age,COUNT(*)

FROM person

GROUP BY age;



**5.HAVING** 组条件：分完组再进行条件筛选

注意：where对行进行筛选，having对组进行筛选

SELECT age,COUNT(*) c

FROM person

GROUP BY age

HAVING c > 1;



**6.ORDER BY** 排序

注意：默认ASC（升序）

SELECT * FROM person ORDER BY id ASC;

SELECT * FROM person ORDER BY id DESC;

# 3-2多表SQL语句



## 第一种：多表连接

**理解：同时查询多张表、先指定公共列、然后再添加其它条件。**



## 第二种：子查询(select语句嵌套)



## (一)多表连接



**(1)**笛卡尔积(m条 * n条)、错误写法

SELECT * FROM company, member



**(2)**多表查询注意、如果查询n张表、至少指定n-1条公共列的条件。

2个表		1个公共列

A表	-	B表	-	C表

SELECT * FROM company, member WHERE company.id = member.comid;

SELECT * FROM company c, member m WHERE c.id = m.comid;

SELECT c.*, m.* FROM company c, member m WHERE c.id = m.comid;



**(3)**多表查询注意事项

**注意一：强烈建议使用**"表名.字段"方式来查询，原因：避免相同字段引用、提高效率。

​	既查特定字段时，必须加别名：（因为字段重名）

SELECT c.name, m.age FROM company c, member m WHERE c.id = m.comid;



**注意二：多表查询如果有相同字段必须起别名**

SELECT c.name cname, m.name mname FROM company c, member m WHERE c.id = m.comid;





**(4)**查询IBM的员工信息

SELECT member.*

FROM company, member

WHERE company.id = member.comid AND company.name = 'IBM'





**(5)**查询小李的公司信息

SELECT company.*

FROM company, member

WHERE company.id = member.comid AND member.name = '小李'





**(6)**左连接（把左表全查出来，）

**注意：以上的写法只查询满足条件的记录。**

**左连接：是把左表中不满足条件的记录也查询出来。左表记录全都查询出来。**



SELECT * FROM company c LEFT JOIN member m ON c.id = m.comid

SELECT * FROM company c LEFT OUTER JOIN member m ON c.id = m.comid





**(7)**右连接

注意：左连接和右连接解决的关注的是不满足条件的记录。

右连接：是把右表中不满足条件的记录也查询出来。右表记录全都查询出来。

SELECT * FROM member m RIGHT JOIN company c ON c.id = m.comid

SELECT * FROM member m RIGHT OUTER JOIN company c ON c.id = m.comid





**(8)**内连接

注意：只查询满足条件的记录

注意：左连接、右连接、内连接的公共列是在on中实现的。不用where。

SELECT * 

FROM member m INNER JOIN company c ON c.id = m.comid



SELECT * 

FROM company c INNER JOIN member m ON c.id = m.comid





## (二)子查询

**注意一：拆分、分步的思想、更符合程序员的思维方式**

**注意二：**select查询语句的嵌套



问题：查询小李的所在公司？



SELECT c.name FROM company c, member m WHERE c.id = m.comid AND m.name = '小李'



**(1)select**子查询

注意：select子查询用于主键查询。

SELECT (SELECT name FROM company WHERE id = comid) 公司名

FROM member 

WHERE name = '小李'



**(2)where**子查询

注意：把查询结果当做条件、比较运算符的子查询必须单值。注意灵活运用。

SELECT NAME

FROM company

WHERE id = (SELECT comid FROM member WHERE name = '小李')



查询小李和小王的所在公司名



SELECT NAME

FROM company

WHERE id in (SELECT comid FROM member WHERE name = '小李' OR name = '小王')



**(3)from**子查询

注意一：select子查询和where子查询的查询结果当做"值"来理解。有语法限制。

注意二：from子查询的查询结果当做"表"来理解。没有语法限制。

注意三：from子查询多用于3表以上的查询。

A表 + B表 =》 中间表 + C表 =》 中间表 + D表 => 结果



SELECT c.name

FROM (SELECT comid cid FROM member WHERE name = '小李') t1, company c

WHERE t1.cid = c.id

# 4 外围



**Mysql**数据库必须掌握：SQL添加、SQL修改、SQL删除、SQL查询(重点、难点)。

**Mysql**数据库扩展内容：约束、limit关键字、视图、关联关系、事务。工具参考手册。百度。



## (一)约束

**说明：数据库设计、开发中使用建模工具生成出来的。例如：**PD等。

1. 非空 not null
2. 唯一 unique
3. 主键约束 primary
4. 外键约束 foreign
5. 检查 check



**(1)**不为空、非空 约束 NOT NULL

- **注意：navicat工具设计表和SWQ实际开中不一样。**
- **注意：navicat工具有欺骗性，可以直接只添加id也能让name有空字符串**

INSERT INTO t1 VALUES(6, 'x');

INSERT INTO t1 VALUES(7, NULL);

INSERT INTO t1 VALUES(8, NULL);

INSERT INTO t1(id) VALUES(8);



**(2)**唯一约束 UNIQUE

- **注意：在索引中添加唯一性，约束名随便起**

INSERT INTO t1 VALUES(7, 'y');



**(3)**主键约束(不为空 + 唯一) PRIMARY KEY

- **注意：本质是 非空 和 唯一 的结合**

INSERT INTO t1(id) VALUES(NULL);

INSERT INTO t1(id) VALUES(1); 



**(4)**外键约束 FOREIGN KEY

- **注意：外键所在原表不可以随意删除 或 修改**
- **注意：不存在的外键，也添加不到有外键约束到表中**
- **注意：想删除到话，先删除子表中数据，再删除主表中数据**

SELECT * FROM t1;

SELECT * FROM t2;



DELETE FROM t2 WHERE comid = 1;

DELETE FROM t1 WHERE id = 1;



UPDATE t1 set id = 3 WHERE id = 1;

INSERT INTO t2 VALUES(4, '赵六', 3);





## (二)LIMIT关键字



**作用一：**top-n分析、前几名、最大值、取前n条

**参数一：表示查询前几条记录。通常和**ORDER BY排序连用。先排序再截取。

SELECT * FROM t1 ORDER BY age LIMIT 3



**作用二：分页、截取表中的一段记录** (起始条数,取这个条数后面的几条）

**参数一：表示起始位置、注意是从零开始计数**

**参数二：表示返回的记录数、通常和**ORDER BY连用、通常按照id降序使用。

SELECT * FROM t1 ORDER BY id DESC

SELECT * FROM t1 ORDER BY id DESC LIMIT 2,2





## (三)视图

**说明：数据库中有很多数据库对象、例如：表、视图、索引、序列、存储过程、触发器等。**

**表：存储数据。**



视图：select查询语句的定义。高效、安全、方便。



索引：提高查询效率。(书的目录、数据库优化、通常是对搜索字段添加索引)。



序列：一组有规则的数值。(生成主键、Hibernate、id生成器、有很多替代技术)。



存储过程：PLQL编程内容。相当于数据库中的方法、可以调用。认为调用。



触发器：PLQL编程内容。在对表中数据进行添加、修改、删除操作之后出发的方法。自动调用。



- 说明：SQL语句是所有关系型数据库通用的结构化查询语言。
- 注意：但是不同的数据库的编程语言是不同的。

Mysql、Oracle：PLSQ编程语言。

SQLServer：TSQL编程语言。转移到数据库开发。



**视图的概念：**select查询语句的定义而已。



**创建表**

CREATE TABLE t3(

id int(2) PRIMARY KEY,

name VARCHAR(10) NOT NULL,

tel VARCHAR(20)

);



**删除表**

DROP TABLE t3;



**创建视图**

CREATE OR REPLACE VIEW view01 AS

SELECT t1.id id3, t1.name name4, t2.id id2, t2.name name2 FROM t1, t2 WHERE t1.id = t2.comid;



**查询视图**

**说明一：**from后边可以写表、也可以写视图

**说明二：**from子查询的本质就是临时视图

**说明三：开发中可以把复杂的查询语句定义为视图存储到数据库端**

**视图好处：简单、安全、高效。表**->视图->我们开发

SELECT * FROM view01;

SELECT * FROM (SELECT t1.id id1, t1.name name1, t2.id id2, t2.name name2 FROM t1, t2 WHERE t1.id = t2.comid) t



**删除视图**

注意：删除视图只是把sql定义删除了、对表没有任何影响。

DROP VIEW view01;





## (四)表与表之间的关联关系

一对一关联：A表中的一条记录对一B表中的一条记录。用户信息（基本信息表、私密信息表）

一对多关联：A表中的一条记录对一B表中的多条记录。项目最最常见。

多对多关联：A表中的一条记录对一B表中的多条记录。B表中的一条记录对一A表中的多条记录。

注意：多对表关联会拆分成2个一对多关联、通过会有一个中间表。

A表		-		C表中间表		-		B表





# 99Mac下卸载MySQL



参考：

https://www.jianshu.com/p/276c1271ae14





# 0 说明及基本使用：





redis命令参考：http://doc.redisfans.com





**Redis的五种数据类型的简单介绍和使用：** https://www.cnblogs.com/dddyyy/p/9803828.html





官网：https://redis.io





redis有哪几种数据类型：

https://www.cnblogs.com/a609251438/p/12075181.html



mac安装参考：https://www.cnblogs.com/DeepInThought/p/10704426.html

- ping通了即可，set\get



配置文件说明 参考：https://www.cnblogs.com/DeepInThought/p/10704764.html



命令参考：http://doc.redisfans.com

http://redis.cn/commands.html







菜鸟教程：https://www.runoob.com/redis/redis-tutorial.html



优质博客：https://blog.csdn.net/jy02268879/category_7732046.html



可视化工具 ：

- 参考：https://www.oschina.net/question/576524_2151241?sort=time

1. **（多人推荐）AnotherRedisDesktopManager：**[**https://github.com/qishibo/AnotherRedisDesktopManager**](https://github.com/qishibo/AnotherRedisDesktopManager)

2. - **使用：**[**https://baijiahao.baidu.com/s?**](https://baijiahao.baidu.com/s?)

3. QuickRedis： https://blog.csdn.net/zhoujianboy/article/details/106353714

4. G-dis： https://blog.csdn.net/ranjio_z/article/details/108562428

5. Redis-admin：https://[github.com/mauersu/redis-admin](http://github.com/mauersu/redis-admin)

6. - **id=1643288952654539693&wfr=spider&for=pc**

7. Medis：https://[www.hangge.com/blog/cache/detail_2671.html](http://www.hangge.com/blog/cache/detail_2671.html)







<dependency>

​	<groupId>org.springframework.boot</groupId>

​	<artifactId>spring-boot-starter-data-redis</artifactId>

</dependency>





- 键值对存储
- 用于缓解数据库压力
- 还可实现登录缓存，登录拦截，具体方法在JavaEE的拦截器中实现





**城市数据库：**





## 使用步骤：



**（**1）安装客户端、可视化界面

mac安装及卸载redis参考： https://www.jianshu.com/p/a2deaab7c0e1





**（**2）打开可视化软件，创建连接

- 新建连接后，默认有15个库







**（**3）创建SB工程时，选Redis、Spring Web、MySQL Driver、Mybatis





**（**4）实体、dao层、业务层和控制层

- 实体中如果需要唯一，在该方法处悬停鼠标，选择随机生成，如下：



- 通过Mybatis生成dao层和mapper映射文件

- 主配置文件配置：

- - mysql数据库连接
  - 扫描mapper映射文件
  - dao层日志级别为debug
  - 配置Redis



spring.datasource.url=jdbc:mysql://127.0.0.1:3306/World?characterEncoding=utf-8&allowMultiQueries=true&zeroDateTimeBehavior=convertToNull&serverTimezone=Asia/Shanghai

spring.datasource.username=root

spring.datasource.password=123456

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver



mybatis.mapper-locations=classpath:mapper/*.xml



logging.level.com.sunrise.springbootredisdemo01.dao=debug



\# Redis

\# Redis服务器地址（必须）

spring.redis.host=localhost

\# Redis服务器连接端口（必须）

spring.redis.port=6379

\# Redis数据库索引（默认为0）

spring.redis.database=0

\# Redis服务器连接密码（默认为空）

spring.redis.password=

\# 连接池最大连接数（使用负值表示没有限制）

spring.redis.jedis.pool.max-active=8

\# 连接池最大阻塞等待时间（使用负值表示没有限制）

spring.redis.jedis.pool.max-wait=-1

\# 连接池中的最大空闲连接

spring.redis.jedis.pool.max-idle=8

\# 连接池中的最小空闲连接

spring.redis.jedis.pool.min-idle=0

\# 连接超时时间（毫秒）

spring.redis.timeout=500







**CityDao.xml**中添加：



<select id="getCityList" resultMap="BaseResultMap">

 select *** from city

</select>





**CityDAO.java**中添加：



List<City> getCityList();





**业务层**

- 接口添加：



  List<City> getCityList();



- 业务层实现类：



@Service

public class CityServiceImpl implements ICityService {



  @Autowired

  private CityDao cityDao;



  @Override

  @Cacheable(cacheNames = "city")

// 通过cacheName设置缓存的key

// 如果redis中有该key则直接返回，若无，则到数据库中查询

  public List<City> getCityList() {

​    return cityDao.getCityList();

  }

}





**控制层：**



@RestController

public class CityController {



  @Autowired

  private ICityService cityService;



  @RequestMapping("getCityList")

  public List<City> getCityList(){

​    return cityService.getCityList();

  }

}





**（**5）添加Redis配置

- 在工程下粘贴下面文件夹





**（**6）添加Fastjson

- fastjson可以将java对象转换为json对象，也可将json对象转换为java对象
- 在pom.xml中添加依赖如下：



<dependency>

  <groupId>com.alibaba</groupId>

  <artifactId>fastjson</artifactId>

  <version>1.2.62</version>

</dependency>





**（**7）配置启动类

- 扫描dao包



@MapperScan("com.xxx.project01.dao")



- 允许该工程使用缓存



@EnableCaching





**（**8）通过Postman测试

- post方式直接访问接口即可





**（**9）清除缓存

- 直接到软件中删除对应的key





# 1 实现登录缓存

- 前提已经有了登录功能
- 主要是用于缓存用户的用户名和token
- 在工程中粘贴下面工具类





**（**1）业务层中添加获取token方法



private String getToken(String account){

  String token = UUID.*randomUUID*().toString();

// 300秒后失效

  redisUtil.set(account,token,300);

  return token;

}



**（**2）业务层中添加验证登录方法



@Override

public Map<String, Object> checkLogin(Map<String, Object> parms) {

  Map<String, Object> result = new HashMap<>();

  String account = parms.get("account").toString();

  String pwd = parms.get("password").toString();

  Userinfo user = userinfoDao.checkLogin(account);

  if(user != null){

​    String password = DigestUtils.*md5DigestAsHex*(pwd.getBytes());

​    if (password.equals(user.getPassword())){

​      result.put("result","1");

​      result.put("userInfo", user);

​      result.put("token",getToken(account));

​    } else {

​      result.put("result", "0");

​    }

  } else {

​    result.put("result", "0");

  }

  return result;

}





**（**3）控制层添加方法



@Autowired

private IUserService userService;



@RequestMapping("checkLogin")

public Map<String, Object> checkLogin(@RequestBody Map<String, Object> parms){

  return userService.checkLogin(parms);

}





**（**4）前端添加依赖







<script src="js/axios.js"></script>

<script src="js/vue.js"></script>





**（**5）body中添加



    <div id="app">

​    id: <input type="text" v-model="parms.account" /><br/>

​    pwd:<input type="text" v-model="parms.password" /><br/>

​    <button type="button" @click="checkLogin">登录</button>

​    <hr>

​    <button type="button" @click="getList">获取数据</button>

  </div>

    <script>

​    var vm = new Vue({

​      el: '#app',

​      data: {

​        parms: {

​          account: '',

​          password: ''

​        },

​        header: {

​          account: '',

​          token: '',

​        }

​      },

​      methods: {

​        checkLogin: function (){

​          axios.request({

​            url: '/checkLogin',

​            method: 'post',

​            data: this.parms

​          }).then(res => {

​            let result = res.data.result

​            if(result == '1'){

​              this.header.account = res.data.userInfo.account

​              this.header.token = res.data.token

​            } else {

​              *alert*("failed")

​            }

​          })

​        }

​      }

​    })

  </script>







# 2 基本使用





**进入**redis：



cd /Library/code/Redis/redis-5.0.4





**启动**redis：

- 启动后，关闭终端即可



redis-server ./redis.conf



redis-server /Library/code/Redis/redis-5.0.4/redis.conf



stredis





**进入**redis：



redis-cli -p 6379





**设：**



set keyName value





**取：**



get keyName





**停止**redis：



redis-cli shutdown





#  



**查看**redis进程，获取 pid：

- 第二列是pid



ps -ef|grep redis



![160725160326151.jpg](/blob:file:/54be7217-9881-4f3b-bd5f-80fd7e55eb0c)



**直接杀进程停止**redis：

- 或者直接去Activity Monitor软件，找到对应pid，强行停止



kill -9 PID







# 3安装可视化界面



 brew cask install another-redis-desktop-manager





# 9 其他 



（不建议）Mac安装、卸载、使用Redis： https://www.jianshu.com/p/a2deaab7c0e1